# Window.requestAnimationFrame()(异步事件) 支持度：window.requestAnimationFrame()这个API是浏览器提供的js全局方法，针对动画效果。使用用法1：```js   function animate() {   //done();   requestAnimationFrame(animate);   }   requestAnimationFrame(animate);```注意函数里的requestAnimationFrame(animate)有了这句话，就形成了递归调用，设置应为这个函数多用在持续的动画中，可以自由处理要不要这句话。用法2：   var globalID;   function animate() {   // done(); 一直运行   globalID=requestAnimationFrame(animate);   // Do something animate   }   globalID=requestAnimationFrame(animate);//开始   cancelAnimationFrame(globalID);//结束setInterval的缺点：setInterval() 方法，不考虑浏览器中发生的事情，如果你正在浏览其他页面，这个函数仍然会每隔几毫秒就会被调用一次，除此之外，setInterval() 方法并没有跟显示器的重画同步，着可能会导致较高的CPU使用，降低系统效率。requestAnimationFrame优点：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。窗口没激活时，动画将停止，省计算资源;使用场景：可以调节重新渲染，大幅提高网页性能。其中最重要的，它可以将某些代码放到下一次重新渲染时执行。避免短时间内触发大量reflow。   function doubleHeight(element) {      var currentHeight = element.clientHeight;      window.requestAnimationFrame(function () {          element.style.height = (currentHeight * 2) + 'px';      });   }   elements.forEach(doubleHeight);页面滚动事件（scroll）的监听函数，就很适合用这个api,推迟到下一次重新渲染。   $(window).on('scroll', function() {        window.requestAnimationFrame(scrollHandler);   });最佳的应用场景还是在帧动画里，可以大幅优化性能；#封装setTimeOut和setInterval    function setTime(fn,times){        var start=new Date()*1         function animate(){             var global=requestAnimationFrame(animate)             if((new Date()*1-start)>=times){                 fn()                cancelAnimationFrame(global)              }         }         requestAnimationFrame(animate)    }    setTime(function(){         console.log(11)    },5000)       function setInt(fn,times){                 function animate(){             fn()             setTime(animate,times)         }         setTime(animate,times)    }    setInt(function(){         console.log(22)    },1000)#移动端事件#pc端事件在移动端的问题​ 移动设备主要特点是不配备鼠标，键盘也只是在需要输入的地方才会激活虚拟键盘。所以以前的pc端事件在移动端使用起来就没有以前那么爽了，虽然部分仍然可以使用。click事件的300ms延迟问题。​2007年第一代iphone发布，由于那个年代所有的网页都是针对大屏的pc端设计的，iphone的Safari浏览器为了让用户浏览网页的时候可以浏览到整个网页，把viewport设置为960px(参考前面的文章)，好是好，但是由于缩放了整个页面，导致内容变得非常小，视力6.0的都不一定看得清楚。​所以Safari浏览器自带了一个当时看起来相当酷的一个功能：双击缩放。你双击页面的时候，浏览器会智能的缩放当前页面到原始大小。​双击缩放的原理就是，当你click一次之后，会经过300ms之后检测是否再有一次click，如果有的话，就会缩放页面。否则的话就是一个click事件。​所以，当你想执行click操作的时候，就感觉到了”卡顿”。如果点击之后100ms之后没有反应，基本就有卡顿的感觉。dblclick事件失效由于双击缩放的存在，pc端的dblclick事件也失效了。#移动端web新增touch事件​随着触屏设备的普及，w3c为移动端web新增了touch事件。​ 为了区别触摸相关的状态改变，存在多种类型的触摸事件。可以通过检查触摸事件的 TouchEvent.type 属性来确定当前事件属于哪种类型。​ 注意:在很多情况下，触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 event.preventDefault()来阻止鼠标事件被触发。Touchstart​ 当用户手指触摸到的触摸屏的时候触发。事件对象的 target 就是touch 发生位置的那个元素。touchmove​ 当用户在触摸屏上移动触点(手指)的时候，触发这个事件。一定是先要触发touchstart事件，再有可能触发 touchmove 事件。​ touchmove 事件的target 与最先触发的 touchstart 的 target 保持一致。touchmove事件和鼠标的mousemove事件一样都会多次重复调用，所以，事件处理时不能有太多耗时操作。不同的设备，移动同样的距离 touchmove 事件的触发频率是不同的。​ 有一点需要注意：即使手指移出了 原来的target 元素，则 touchmove 仍然会被一直触发，而且 target 仍然是原来的 target 元素。touchend​ 当用户的手指抬起的时候，会触发 touchend 事件。如何用户的手指从触屏设备的边缘移出了触屏设备，也会触发 touchend 事件。​ touchend 事件的 target 也是与 touchstart 的 target 一致，即使已经移出了元素。touchcancel​ 当触点由于某些原因被中断时触发。有几种可能的原因如下(具体的原因根据不同的设备和浏览器有所不同):由于某个事件取消了触摸：例如触摸过程被一个模态的弹出框打断。触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。当用户产生的触点个数超过了设备支持的个数，从而导致 TouchList 中最早的 Touch对象被取消#Touch详解​ 表示用户和触摸设备之间接触时单独的交互点(a single point of contact)。 这个交互点通常是一个手指或者触摸笔。触摸设备通常是触摸屏或者触摸板。js对象提供了多个属性来描述Touch对象。基本属性:（只读属性）identifier:表示每 1 个 Touch 对象 的独一无二的 identifier。有了这个 identifier 可以确保你总能追踪到这个 Touch对象。screenX:触摸点相对于屏幕左边缘的 x 坐标。screenY:触摸点相对于屏幕上边缘的 y 坐标。clientX:触摸点相对于浏览器的 viewport左边缘的 x 坐标。不会包括左边的滚动距离。clientY:触摸点相对于浏览器的 viewport上边缘的 y 坐标。不会包括上边的滚动距离。pageX:触摸点相对于 document的左边缘的 x 坐标。 与 clientX 不同的是，他包括左边滚动的距离，如果有的话。pageY:触摸点相对于 document的左边缘的 y 坐标。 与 clientY 不同的是，他包括上边滚动的距离，如果有的话。target:总是表示 手指最开始放在触摸设备上的触发点所在位置的 element。 即使已经移出了元素甚至移出了document, 他表示的element仍然不变#封装移动端事件前面的是最基本的事件，直接使用相对比较麻烦，所以有必要对一些常用事件进行封装。比如：单击事件、双击事件、滑动方向等封装：   (function (window){  //传入window，提高变量的查找效率    function myQuery(selector){  //这个函数就是对外提供的接口。        //调用这个函数的原型对象上的_init方法，并返回        return myQuery.prototype._init(selector);    }    myQuery.prototype = {        /*初始化方法，获取当前query对象的方法*/        _init: function (selector){            if (typeof selector == "string"){                //把查找到的元素存入到这个原型对象上。                this.ele = window.document.querySelector(selector);                //返回值其实就是原型对象。                return this;            }        },        /*单击事件：         * 为了规避click的300ms的延迟，自定义一个单击事件         * 触发时间：         *   当抬起手指的时候触发         *   需要判断手指落下和手指抬起的事件间隔，如果小于500ms表示单击时间。         *         *   如果是大于等于500ms，算是长按时间         * */        tap: function (handler){            this.ele.addEventListener("touchstart", touchFn);            this.ele.addEventListener("touchend", touchFn);            var startTime,                endTime;            function touchFn(e){                e.preventDefault()                switch (e.type){                    case "touchstart":                        startTime = new Date().getTime();                        break;                    case "touchend":                        endTime = new Date().getTime();                        if (endTime - startTime < 500){                            handler.call(this, e);                        }                        break;                }            }        },        /**         * 长按         * @param handler         */        longTag: function (handler){            this.ele.addEventListener("touchstart", touchFn);            this.ele.addEventListener("touchmove", touchFn);            this.ele.addEventListener("touchend", touchFn);            var timerId;            function touchFn(e){                switch (e.type){                    case "touchstart" :  //500ms之后执行                        timerId = setTimeout(function (){                            handler.call(this, e);                        }, 500)                        break;                    case "touchmove" :                        //如果中间有移动也清除定时器                        clearTimeout(timerId)                        break;                    case "touchend" :                        //如果在500ms之内抬起了手指，则需要定时器                        clearTimeout(timerId);                        break;                }            }        },        /**         * 左侧滑动。            记录手指按下的左边，在离开的时候计算 deltaX是否满足左滑的条件         *         */        slideLeft: function (handler){            this.ele.addEventListener("touchstart", touchFn);            this.ele.addEventListener("touchend", touchFn);            var startX, startY, endX, endY;            function touchFn(e){                e.preventDefault();                var firstTouch = e.changedTouches[0];                switch (e.type){                    case "touchstart":                        startX = firstTouch.pageX;                        startY = firstTouch.pageY;                        break;                    case "touchend":                        endX = firstTouch.pageX;                        endY = firstTouch.pageY;//x方向移动大于y方向的移动，并且x方向的移动大于25个像素，表示在向左侧滑动                        if (Math.abs(endX - startX) >= Math.abs(endY - startY) && startX - endX >= 25){                            handler.call(this, e);                        }                        break;                }            }        },        /**         * 右侧滑动。         *         */        rightLeft: function (e){            //TODO:        }    }    window.$ = window.myQuery = myQuery;})(window);使用：$("div").tap(function (e){    console.log("单击事件")})$("div").longTag(function (){    console.log("长按事件");})$("div").slideLeft(function (e){    console.log(this);    this.innerHTML = "左侧滑动了....."})#前端存储客户端在没有数据库的情况，做为记录状态的方式之一，可以为当前平台，当前网站进行客户端数据的保存，以及多页面间的数据交互通信；是浏览器的一种状态记录方式；#CookieCookie：存在于http请求的头部，始终在客户端和服务端通讯的过程，进行携带；具有一定性能的浪费；当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。#特征cookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域以及当前域下的所有子域一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样,一般为20个。每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁#设置客户端设置document.cookie = '名字=值';document.cookie = 'username=cfangxu;domain=baike.baidu.com'//并且设置了生效域注意：客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。服务器端设置不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。Set-Cookie 消息头是一个字符串，其格式如下（中括号中的部分是可选的）：Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]注意：一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly通过 Set-Cookie 指定的这些可选项只会在浏览器端使用，而不会被发送至服务器端。#读取document.cookie：例如 username=chenfangxu;job=coding#修改cookie**       **要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。#删除把要删除的cookie的过期时间设置成已过去的时间,path/domain/这几个选项一定要旧cookie 保持一样。#cookie的属性（可选项）过期时间一个设置cookie时效性的例子：   function setCookie(c_name, value, expiredays){         var exdate=new Date();         exdate.setDate(exdate.getDate() + expiredays);         document.cookie=c_name+ "=" + escape(value) + ((expiredays==null) ? "" :         ";expires="+exdate.toGMTString())   }使用方法:      setcookie('username','zxy',30);注：expires 是 http/1.0协议中的选项max-age：1.1中的max-age用秒来设置cookie的生存期，0;//不记录cookie-1;//会话级cookie，关闭浏览器失效3600;//过期时间为1小时（从文档第一次加载开始计算时间）path属性它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。domain属性domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.example.com的服务器能够读取catalog.example.com设置的cookie值。如果catalog.example.com的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.example.com”，那么所有位于catalog.example.com的网页和所有位于orlders.example.com的网页，以及位于example.com域的其他服务器上的网页都可以访问这个coolie。secure属性它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输#服务端设置httpOnly这个选项用来设置cookie是否能通过 js去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。cookie的编码cookie其实是个字符串，但这个字符串中等号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；当然也可以用encodeURIComponent/decodeURIComponent或者encodeURI/decodeURI，查看关于编码的介绍#localStorage，sessionStorage#localStorage对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。不管是 localStorage，还是sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：保存数据：localStorage.setItem(key,value);读取数据：localStorage.getItem(key);删除单个数据：localStorage.removeItem(key);删除所有数据：localStorage.clear();得到某个索引的key：localStorage.key(index);sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。使用方法：保存数据：sessionStorage.setItem("website", "W3Cfuns.com");读取数据：sessionStorage.getItem("website");#websqlWeb SQL Database 规范中定义的三个核心方法：openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象transaction：这个方法允许我们根据情况控制事务提交或回滚executeSql：这个方法用于执行SQL 查询。#openDatabase我们可以使用这样简单的一条语句，创建或打开一个本地的数据库对象   var db = openDatabase('testDB', '1.0', 'Test DB', 2 * 1024 * 1024);openDatabase接收五个参数：   var config = {      name: 'testDB',//数据库名字      version: '1.0', //数据库版本      desc: '测试前端数据库', //数据库描述      size: 2 * 1024 * 1024 //数据库大小 这里为2M，单位为B   };   var db = window.openDatabase(config.name, config.version, config.desc,   config.size);   #常见sql语句：1、	表查询语句字符串查询范围   select * from school where id='aa'数值查询范围   select id,name from school where num>1模糊查询   select * from school where name like '% 陈%'数据截取(截取前十条数据)   select * from school limit 0,10数据查询排序(desc降序，asc升序)   select * from school limit 0,10 order by desc 表连接查询（多表查询，表结构相同）   select * from (select * from table_a UNION ALL select * from table_b)as tabel_all2、	表插入语句单纯插入表数据insert into tabel_a(id,name) values(1,”chen”)创建新表，并复制另外一个表格中的数据select id,name into tabel_b from table_a复制另外一个表中数据进行插入insert into tabte_b(id,name) select id，name from tabel_a3、	删除表数据 delete from class_one_list where id=‘1’4、	更新表数据update class_one_list set twoListNum=’1’,artListNum=’2’ where id=’2’5、	创建表CREATE TABLE person (number INT(11), name VARCHAR(255), birthday DATE);6、	修改表名	alter table table_name rename table_new_name7、	删除表	DROP TABLE  tbl_name;#transaction和executeSql整体使用：   db.transaction(function(tx) {      tx.executeSql(sql, null, function(tx, rs) {         console.log('执行sql成功');      }, errorCallback);   });由于Web SQL Database规范已经被废弃，原因说的很清楚，当前的SQL规范采用SQLite的SQL方言，而作为一个标准，这是不可接受的#websql封装使用：(function (window) {    var config = {        name: 'testDB', //数据库名字        version: '1.0', //数据库版本        desc: '测试前端数据库', //数据库描述        size: 2 * 1024 * 1024 //数据库大小 这里为2M，单位为B    };    // 1、先创建一个数据库    var db = window.openDatabase(config.name, config.version, config.desc,        config.size);    var obj={        // 读取数据        read:function (sql) {            return new Promise((res,rej)=>{                db.transaction(function (tx) {                        tx.executeSql(sql, null, function (tx, rs) {                        var data=Array.prototype.slice.call(rs.rows)                                                res(data)                    }, function (tx,err) {                        // console.log(err)                        rej(err)                    });                        });            })                   },        handle(sql){            return new Promise((res,rej)=>{                db.transaction(function (tx) {                        tx.executeSql(sql, null, function (tx, rs) {                                               res("执行成功")                    }, function (tx,err) {                        // console.log(err)                        rej(err)                    });                        });            })                   }    }    window.db=obj    })(window)//使用db.read(sql).then((data)=>{}).catch((err)=>{})#indexedDBIndexedDB是HTML5规范里新出现的浏览器里内置的数据库。对于在浏览器里存储数据，你可以使用cookies或localstorage，但它们都是比较简单的技术，而IndexedDB提供了类似数据库风格的数据存储和使用方式。存储在IndexedDB里的数据是永久保存，不像cookies那样只是临时的。IndexedDB里提供了查询数据的功能，在online和offline模式下都能使用。你可以用IndexedDB存储大型数据。IndexedDB里数据以对象的形式存储，每个对象都有一个key值索引。IndexedDB里的操作都是事务性的。一种对象存储在一个objectStore里，objectStore就相当于关系数据库里的表。IndexedDB可以有很多objectStore，objectStore里可以有很多对象。每个对象可以用key值获取。1、indexedDB VS LocalStorageIndexedDB和LocalStorage都是用来在浏览器里存储数据，但它们使用不同的技术，有不同的用途，你需要根据自己的情况适当的选择使用哪种。LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，它的api是同步的。IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。2、IndexedDB vs Web SQLWebSQL也是一种在浏览器里存储数据的技术，跟IndexedDB不同的是，IndexedDB更像是一个NoSQL数据库，而WebSQL更像是关系型数据库，使用SQL查询数据。W3C已经不再支持这种技术。因为不再支持上面也大致分析了其用法，也就不再赘诉。3、IndexedDB vs CookiesCookies(小甜点)听起来很好吃，但实际上并不是。每次HTTP接受和发送都会传递Cookies数据，它会占用额外的流量。例如，如果你有一个10KB的Cookies数据，发送10次请求，那么，总计就会有100KB的数据在网络上传输。Cookies只能是字符串。浏览器里存储Cookies的空间有限，很多用户禁止浏览器使用Cookies。所以，Cookies只能用来存储小量的非关键的数据。4、IndexedDB的用法想要理解这个API，最好的方法是创建一个简单的web应用：比如把你们班的学生的学号和姓名存储在IndexedDB里。IndexedDB里提供了简单的增、删、改、查接口。(1)、浏览器是否支持：   window.indexedDB = window.indexedDB || window.mozIndexedDB ||   window.webkitIndexedDB || window.msIndexedDB;   if(!window.indexedDB){      console.log("你的浏览器不支持IndexedDB");   }(2)、创建一旦你的浏览器支持IndexedDB，我们就可以打开它。但不能直接打开IndexedDB数据库。IndexedDB需要你创建一个请求来打开它。   // 第一个参数，数据库的名字，第二个参数为数据库的版本   var request = window.indexedDB.open("testDB", 2);   var db;   // 打开数据库失败监听   request.onerror = function(event) {      console.log("打开DB失败", event);   }   // 页面第一此请求时，或版本更新时的事件监听，可以创建你初始化的存储数据   request.onupgradeneeded = function(event) {      console.log("Upgrading");      db = event.target.result;      //检测一张表存不存在，不存在就进行创建      if (!db.objectStoreNames.contains('students')) {         //（1）  类似与创建关系型数据库中的一张表         var objectStore = db.createObjectStore("students", {            keyPath: "id"  //主键为id         });         // （2）如果没有可以设置的主键，主键为一个递增的整数，可以进行如下设置         // var objectStore = db.createObjectStore('person',{          //       autoIncrement: true          //    });      }    };   // 数据库打开成功时的事件监听   request.onsuccess = function(event) {      console.log("成功打开DB");      db = event.target.result;   }(3)增——往ObjectStore里新增对象为了往数据库里新增数据，我们首先需要创建一个事务，并要求具有读写权限。在indexedDB里任何的存取对象的操作都需要放在事务里执行。   //添加数据   function add() {      db.transaction(["students"], "readwrite").objectStore("students").add({         students: "1",         name: "zhangsan"      })   }(4)删——ObjectStore里删除对象删除跟新增一样，需要创建事务，然后调用删除接口，通过key删除对象。function deleteHandle() {   var request = db.transaction(["students"], "readwrite").objectStore("students").delete("1")    request.onsuccess = function (event) {      console.log('数据删除成功');   };}(5)查——通过key取出对象，即往get()方法里传入对象的key值，取出相应的对象。//读取数据function select() {   var request = db.transaction(["students"], "readwrite")   .objectStore("students").get("1")  request.onerror = function(event) {     console.log('事务失败');   };   request.onsuccess = function(data) {      if (request.result) {        console.log('Name: ' + request.result.name);        console.log('Age: ' + request.result.age);        console.log('Email: ' + request.result.email);      } else {        console.log('未获得数据记录');      }   }}(6)读取所有的数据function readAll() {  var objectStore = db.transaction('students').objectStore('students');   objectStore.openCursor().onsuccess = function (event) {     var cursor = event.target.result;     if (cursor) {       console.log('Id: ' + cursor.key);       console.log('Name: ' + cursor.value.name);       console.log('Age: ' + cursor.value.age);       console.log('Email: ' + cursor.value.email);       cursor.continue();    } else {      console.log('没有更多数据了！');    }  };}readAll();(7)更新数据function update() {  var request = db.transaction(['students'], 'readwrite')    .objectStore('students')    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });  request.onsuccess = function (event) {    console.log('数据更新成功');  };  request.onerror = function (event) {    console.log('数据更新失败');  }}update();#封装使用function IDB(config) {            var config = Object.assign({                db: "testDB",                version: 2,                store: "students",                type: {                    keyPath: "id"                }            },config?config:{})            window.indexedDB = window.indexedDB || window.mozIndexedDB ||                window.webkitIndexedDB || window.msIndexedDB;            if (!window.indexedDB) {                console.log("你的浏览器不支持IndexedDB");            }            // 第一个参数，数据库的名字，第二个参数为数据库的版本            var request = window.indexedDB.open(config.db, config.version);            var db;            // 打开数据库失败监听            request.onerror = function (event) {                console.log("打开DB失败", event);            }            // 页面第一此请求时，或版本更新时的事件监听，可以创建你初始化的存储数据            request.onupgradeneeded = function (event) {                console.log("Upgrading");                db = event.target.result;                //检测一张表存不存在，不存在就进行创建                if (!db.objectStoreNames.contains(config.store)) {                    //（1）  类似与创建关系型数据库中的一张表                    var objectStore = db.createObjectStore(config.store, config.type);                    // （2）如果没有可以设置的主键，主键为一个递增的整数，可以进行如下设置                    // var objectStore = db.createObjectStore('person',{                     //       autoIncrement: true                     //    });                }            };            // 数据库打开成功时的事件监听            return new Promise((res, rej) => {                request.onsuccess = function (event) {                    console.log("成功打开DB");                    db = event.target.result;                    //添加                    function add(store, data) {                        return new Promise((resolve, reject) => {                            var request = db.transaction([store], "readwrite").objectStore(store).add(data)                            request.onsuccess = function () {                                resolve("添加成功")                            }                            request.onerror = function () {                                reject("添加失败")                            }                        })                    }                    //读取数据                    function read(store, key) {                        return new Promise((res, rej) => {                            var request = db.transaction([store], "readwrite")                                .objectStore(store).get(key)                            request.onerror = function (event) {                                // console.log('事务失败');                                rej(event)                            };                            request.onsuccess = function () {                                if (request.result) {                                    // console.log(request.result);                                    res(request.result)                                } else {                                    rej('未获得数据记录')                                    // console.log('未获得数据记录');                                }                            }                        })                    }                    //读取所有数据                    function readAll(store) {                        return new Promise((res, rej) => {                            var request = db.transaction([store], "readwrite").objectStore(store).openCursor();                            var arr = []                            request.onsuccess = function (event) {                                var cursor = event.target.result;                                if (cursor) {                                    arr.push(cursor.value)                                    cursor.continue();                                } else {                                    // console.log(arr)                                    res(arr)                                    // console.log('没有更多数据了！');                                }                            };                            request.onerror = function (event) {                                // console.log('事务失败');                                rej(event)                            };                        })                    }                    function update(store,data) {                        return new Promise((res, rej) => {                            var request = db.transaction([store], 'readwrite')                                .objectStore(store)                                .put(data);                            request.onsuccess = function (event) {                                res('数据更新成功');                            };                            request.onerror = function (event) {                                rej('数据更新失败');                            }                        })                    }                    function del(store, key) {                        return new Promise((res, rej) => {                            var request = db.transaction([store], "readwrite").objectStore(store).delete(key)                            request.onsuccess = function (event) {                                res('数据删除成功');                            };                            request.onerror = function (event) {                                rej('数据删除失败');                            };                        })                    }                    res({                        add,                        read,                        readAll,                        del,                        update                    })                }            })        }   //使用   IDB().then((db)=>{      db.add("students",{         id:"1",         name:"zhangsan"      }).then((data)=>{         console.log(data)      })   })#拖放拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。拖拽：Drag释放：Drop拖拽指的是鼠标点击源对象后一直移动对象不松手，一但松手即释放了源对象&目标对象源对象： 指的是我们鼠标点击的一个事物，这里可以是一张图片，一个DIV，一段文本等等。目标对象： 指的是我们拖动源对象后移动到一块区域，源对象可以进入这个区域，可以在这个区域上方悬停(未松手)，可以松手释放将源对象放置此处(已松手)，也可以悬停后离开该区域。事件被拖动的源对象可以触发的事件：(1)ondragstart：源对象开始被拖动(2)ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动)(3)ondragend：源对象被拖动结束目标对象可以触发的事件：(1)ondragenter：目标对象被源对象拖动着进入(2)ondragover：目标对象被源对象拖动着悬停在上方(3)ondragleave：源对象拖动着离开了目标对象(4)ondrop：源对象拖动着在目标对象上方释放/松手事件对象HTML5为所有的拖动相关事件提供了一个新的属性：e.dataTransfer { }         //数据传递对象功能：用于在源对象和目标对象的事件间传递数据源对象上的事件处理中保存数据：   e.dataTransfer.setData( k,  v );     //k-v必须都是string类型目标对象上的事件处理中读取数据：   var v = e.dataTransfer.getData( k );注：ondragover有一个默认行为！！！那就是当ondragover触发时，ondrop会失效！！！！这个可能是浏览器的版本问题，需要以后浏览器不断更新可能才会解决！！如何阻止？   ondragover= function(e){ //源对象在悬停在目标对象上时      e.preventDefault(); //阻止默认行为，使得drop可以触发   }   ondrop= function(e){ //源对象松手释放在了目标对象中      .   }案例：垃圾桶<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        div {            width: 200px;            height: 300px;            border: 1px solid black;        }    </style></head><body>    <ul>        <li>            <img class="img" src="./img/icon.png" alt="">        </li>        <li>            <img class="img" src="./img/icon1.png" alt="">        </li>        <li>            <img class="target" src="./img/icon2.png" alt="">        </li>    </ul>    <script>        var $img = document.querySelectorAll(".img")        var $target = document.querySelector(".target")        for (let i = 0; i < $img.length; i++) {            const element = $img[i];            element.ondragstart=function(e){                console.log(e)                e.dataTransfer.setData("el",i)            }           }        $target.ondragover = function (e) { //源对象在悬停在目标对象上时            e.preventDefault(); //阻止默认行为，使得drop可以触发        }        $target.ondrop = function (e) {            console.log(e.dataTransfer.getData("el"))            var i=e.dataTransfer.getData("el")            $img[i].parentNode.parentNode.removeChild($img[i].parentNode)        }    </script></body></html>#FileReader在html5中新增的文件操作：File： 代表一个文件对象FileList： 代表一个文件列表对象，类数组FileReader： 用于从文件中读取数据FileWriter： 用于向文件中写出数据#fileReader对象FileReader实例拥有四个方法，其中三个是用来读取文件，另一个是用来中断读取的。需要注意的是，无论读取成功或是失败，方法并不会返回读取结果，这一结果(储存在result属性中)要用FileReader处理事件去获取；方法名	参数	描述abort	none	中断读取readAsBinaryString	file	将文件转化为二进制码readAsDataURL	file	将文件读取为DataURLreadAsText	file,[encoding]	将文件读取为文本readAsText：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8。这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容。 readAsBinaryString：该方法将文件读取为二进制字符串，通常我们将它传送到后端，后端可以通过这段字符串存储文件。 readAsDataURL：这是例子程序中用到的方法，该方法将文件读取为一段以 data: 开头的字符串，这段字符串的实质就是 Data URL，Data URL是一种将小文件直接嵌入文档的方案。这里的小文件通常是指图像与 html 等格式的文件。事件 监听函数FileReader 包含了一整套完成的事件模型，用于捕获读取文件时的状态,下面这个表格归纳了这些事件。事件	描述onabort	中断时触发onerror	出错时触发onload	文件读取成功完成时触发onloadend	读取完成时触发，无论读取成功或失败onloadstart	读取开始时触发onprogress	读取中案例：图片，文件拖拽至浏览器，进行展示<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        * {            margin: 0;            padding: 0        }        div {            width: 300px;            height: 200px;            border: 1px solid black;        }    </style></head><body>    <div>    </div>    <script>        var $div = document.querySelector("div")        $div.ondragover = function (e) {            e.preventDefault()        }        $div.ondrop = function (e) {            e.preventDefault()            var file = new FileReader()            var file0 = e.dataTransfer.files[0]            if (file0.type.indexOf("image") >= 0) {                file.readAsDataURL(file0)                file.onload = function () {                    var str = `<img src='${file.result}' style="width:100%">`                    $div.innerHTML = str                }                            } else {                file.readAsText(file0)                file.onload = function () {                    $div.innerHTML = file.result                }            }        }    </script></body></html>#地理定位常见的定位方式有基站定位，WiFi定位，IP定位，GPS定位等# 基站定位基站是能进行信号交换的站点。手机能接受信号，打电话就是通过手机基站。这些基站是由国家移动通信运营商建的，比如中国移动，中国联通，中国电信。原理如下，通过手机接受不同几个基站的信号强度来判断二者之间距离，当然基站的位置信息本来是已知的，所以手机的位置就知道了。前提是手机必须处于SIM卡注册状态下。由于手机信号会受干扰，基站定位精度较低。而且精度也受基站的密度影响，密度越大越精准。# WiFi定位WiFi是无线上网的一种技术。平时手机不连上WiFi的功能就能定位。大致的原理是，WiFi信号被设备检测到，数据库记录这个WiFi信号和设备对应的位置。当它被越来越多的设备检测到，它的位置就可以利用这些数据通过某种算法来得出。由于信号随着距离的增加而减少，根据设备获取到的WiFi信号强度就可以计算出两者之间的距离。知道了周围几个点，以及与这些点之间的距离，待定位的设备位置就不难计算出来了。WiFi定位是由谷歌提出的，主要解决了室内定位的问题。缺点是，当某个WiFi搬家的时候，数据库没有及时更新，就会出现定位不准的问题。# IP定位每个能联网的设备都被分配了一个ip，通过查到数据库，可以粗略地知道这个ip所在的地理位置。你可以点这里试试IP定位。# GPS定位GPS，全称Global Position System，全球定位系统，简单的说，就是天上有很多卫星(24颗)，通过4颗卫星的位置以及卫星与待定位设备之间的距离，计算出该设备的位置。GPS精度高，但费电。还有在室内的时候，讯号就会被阻挡 ，所以室内GPS定位不准。# AGPS定位AGPS是Assisted GPS的意思。由于GPS定位最初使用都有一个冷启动时间（2-3分钟），在此之前先借助其他的定位方式进行粗略地定位，然后可以较快地根据GPS进行精确定位。一般借用的辅助定位方式为基站定位# 定位技术比较以上的定位方式各有优缺点，实际开发中一般同时采用多个定位方式进行定位。定位方式	应用场景	优点	缺点基站定位	能通电话的手机	快速，耗能小	受基站的密度影响，信号也会被干扰WiFi定位	有WiFi的地方	精度尚可，解决室内定位问题	WiFi数据库更新不及时IP定位	能上网的设备		精度依赖数据库GPS定位	室外	精确度高	不能用于室内，首次定位较慢AGPS定位	同上	同上，解决了首次定位慢的问题	不能用于室内#Html5地理定位：浏览器支持Internet Explorer 9、Firefox、Chrome、Safari 以及 Opera 支持地理定位。getCurrentPosition() 方法 - 返回数据若成功，则 getCurrentPosition() 方法返回对象。始终会返回 latitude、longitude 以及 accuracy 属性。如果可用，则会返回其他下面的属性。属性	描述coords.latitude	十进制数的纬度coords.longitude	十进制数的经度coords.accuracy	位置精度coords.altitude	海拔，海平面以上以米计coords.altitudeAccuracy	位置的海拔精度coords.heading	方向，从正北开始以度计coords.speed	速度，以米/每秒计timestamp	响应的日期/时间Geolocation 对象 - 其他有趣的方法watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。clearWatch() - 停止 watchPosition() 方法下面的例子展示 watchPosition() 方法。您需要一台精确的 GPS 设备来测试该例（比如 iPhone）：var x = document.getElementById("demo");function getLocation() {   if (navigator.geolocation) {      console.log(111)      navigator.geolocation.getCurrentPosition(showPosition, showError, {         // 指示浏览器获取高精度的位置，默认为false         enableHighAccuracy: true,         // 指定获取地理位置的超时时间，默认不限时，单位为毫秒         timeout: 5000,         // 最长有效期，在重复获取地理位置时，此参数指定多久再次获取位置。         maximumAge: 3000      });   } else {      console.log("222")      x.innerHTML = "Geolocation is not supported by this browser.";   }}getLocation()//展示经纬度function showPosition(position, a) {   console.log(position, a)   x.innerHTML = "Latitude: " + position.coords.latitude +"\<br /\>Longitude: " + position.coords.longitude;}//错误的展示function showError(error) {   console.log(error)   switch (error.code) {      case error.PERMISSION_DENIED:         x.innerHTML = "User denied the request for Geolocation."         break;      case error.POSITION_UNAVAILABLE:         x.innerHTML = "Location information is unavailable."         break;      case error.TIMEOUT:         x.innerHTML = "The request to get user location timed out."         break;      case error.UNKNOWN_ERROR:         x.innerHTML = "An unknown error occurred."         break;   }}注：上述原生方案只有在ie中进行测试成功，其他浏览器都不可以；因为服务器被强的原因百度地图sdk开发实战：微信sdk，百度地图sdk，高德sdk#Video & Radio#Video直到现在，仍然不存在一项旨在网页上显示视频的标准。今天，大多数视频是通过插件（比如 Flash）来显示的。然而，并非所有浏览器都拥有同样的插件。HTML5 规定了一种通过 video 元素来包含视频的标准方法。<video> 元素提供了 播放、暂停和音量控件来控制视频。同时 <video> 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。<video> 与</video> 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。<video> 元素支持多个 <source> 元素. <source> 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式：支持的格式：MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件常用属性属性	描述audioTracks	返回表示可用音频轨道的 AudioTrackList 对象。autoplay	设置或返回是否在就绪（加载完成）后随即播放视频。buffered	返回表示视频已缓冲部分的 TimeRanges 对象。controller	返回表示视频当前媒体控制器的 MediaController 对象。controls	设置或返回视频是否应该显示控件（比如播放/暂停等）。crossOrigin	设置或返回视频的 CORS 设置。currentSrc	返回当前视频的 URL。currentTime	设置或返回视频中的当前播放位置（以秒计）。defaultMuted	设置或返回视频默认是否静音。defaultPlaybackRate	设置或返回视频的默认播放速度。duration	返回视频的长度（以秒计）。ended	返回视频的播放是否已结束。error	返回表示视频错误状态的 MediaError 对象。height	设置或返回视频的 height 属性的值。loop	设置或返回视频是否应在结束时再次播放。mediaGroup	设置或返回视频所属媒介组合的名称。muted	设置或返回是否关闭声音。networkState	返回视频的当前网络状态。paused	设置或返回视频是否暂停。playbackRate	设置或返回视频播放的速度。played	返回表示视频已播放部分的 TimeRanges 对象。poster	设置或返回视频的 poster 属性的值。preload	设置或返回视频的 preload 属性的值。readyState	返回视频当前的就绪状态。seekable	返回表示视频可寻址部分的 TimeRanges 对象。seeking	返回用户当前是否正在视频中进行查找。src	设置或返回视频的 src 属性的值。startDate	返回表示当前时间偏移的 Date 对象。textTracks	返回表示可用文本轨道的 TextTrackList 对象。videoTracks	返回表示可用视频轨道的 VideoTrackList 对象。volume	设置或返回视频的音量。width	设置或返回视频的 width 属性的值。常用事件：值	描述onabort	script	当发生中止事件时运行脚本oncanplay	script	当媒介能够开始播放但可能因缓冲而需要停止时运行脚本oncanplaythrough	script	当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本ondurationchange	script	当媒介长度改变时运行脚本onemptied	script	当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本onended	script	当媒介已抵达结尾时运行脚本onerror	script	当在元素加载期间发生错误时运行脚本onloadeddata	script	当加载媒介数据时运行脚本onloadedmetadata	script	当媒介元素的持续时间以及其他媒介数据已加载时运行脚本onloadstart	script	当浏览器开始加载媒介数据时运行脚本onpause	script	当媒介数据暂停时运行脚本onplay	script	当媒介数据将要开始播放时运行脚本onplaying	script	当媒介数据已开始播放时运行脚本onprogress	script	当浏览器正在取媒介数据时运行脚本onratechange	script	当媒介数据的播放速率改变时运行脚本onreadystatechange	script	当就绪状态（ready-state）改变时运行脚本onseeked	script	当媒介元素的定位属性 [1] 不再为真且定位已结束时运行脚本onseeking	script	当媒介元素的定位属性为真且定位已开始时运行脚本onstalled	script	当取回媒介数据过程中（延迟）存在错误时运行脚本onsuspend	script	当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本ontimeupdate	script	当媒介改变其播放位置时运行脚本onvolumechange	script	当媒介改变音量亦或当音量被设置为静音时运行脚本onwaiting	script	当媒介已停止播放但打算继续播放时运行脚本对象方法方法	描述addTextTrack()	向视频添加新的文本轨道。canPlayType()	检查浏览器是否能够播放指定的视频类型。load()	重新加载视频元素。play()	开始播放视频。pause()	暂停当前播放的视频。实现字幕：创建字母文件.vtt:   WEBVTT   Cue-1   00:00:15.000 --> 00:00:18.000   At the left we can see...潜入文件：   <video controls>      <source src="/vedio/b.mp4" type="video/mp4">         <track label="English subtitles" kind="subtitles" srclang="en"         src="/vedio/vtt.vtt" default>         <track label="Deutsche Untertitel" kind="subtitles" srclang="de"         src="/vedio/vtt.vtt">         <track label="English chapters" kind="chapters" srclang="en"         src="/vedio/vtt.vtt">   </video>#Audio方法	描述addTextTrack()	向音频添加新的文本轨道。canPlayType()	检查浏览器是否能够播放指定的音频类型。fastSeek()	在音频播放器中指定播放时间。getStartDate()	返回新的 Date 对象，表示当前时间线偏移量。load()	重新加载音频元素。play()	开始播放音频。pause()	暂停当前播放的音频。注：其他方法跟vedio一样案例：实现音乐播放器#Swiper#Better-scrollbetter-scroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。better-scroll 是基于原生 JS 实现的，不依赖任何框架。它编译后的代码大小是 63kb，压缩后是 35kb，gzip 后仅有 9kb，是一款非常轻量的 JS lib。#下载Npm下载：npm install better-scroll –savejs下载：https://unpkg.com/better-scroll/dist/bscroll.min.js或者：打开地址**：**https://github.com/ustbhuangyi/better-scroll/tree/master/dist注：在使用容器内部滚动时，必须将容器进行定位，否则会和浏览器的全局滚动想冲突#使用Demo：<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        * {            margin: 0;            padding: 0;            list-style: none;        }                html {            font-size: calc(100/750*100vw);        }                li {            height: 3rem;        }                li:nth-child(1) {            background: red;        }                li:nth-child(2) {            background: green;        }                li:nth-child(3) {            background: lightblue;        }                li:nth-child(4) {            background: lightpink;        }                li:nth-child(5) {            background: lightslategray;        }        /* 纵向滚动 */                .vertical {            height: 3rem;            width: 7.5rem;            position: relative;            overflow: hidden;        }        /* 测试横向滚动 */                .vertical li {            width: 20rem;        }                .vertical ul {            width: 20rem;        }            </style></head><body>    <div class="vertical">        <ul>            <li>1</li>            <li>2</li>            <li>3</li>            <li>4</li>            <li>5</li>        </ul>    </div>    <script src="./tool/bscroll.min.js"></script>    <script>        let scrollV = new BScroll('.vertical', {            scrollbar: true, //默认为 false。当设置为 true 或者是一个 Object 的时候，都会开启滚动条            scrollY: true, //垂直滚动            scrollX: true, //水平滚动                 })        // 事件监听相关        let $li = document.querySelector(".vertical").children;        [...$li].forEach((dom) => {            dom.addEventListener('tap', function() {                console.log(22)            }, false)        })        scrollV.on("scroll", function() {            console.log(22)        })    </script></body></html>#常用api实例化滚动条new BScroll(加滚动条的父元素,{配置项})配置项：   {      scrollbar: true, //默认为 false。当设置为 true 或者是一个 Object 的时候，都会开启滚动条      scrollY: true, //垂直滚动      scrollX: true, //水平滚动      // eventPassthrough: "horizontal", //开启此属性，横向的滚动效果失效      // freeScroll: true, //开启后可以实现横向和纵向同时滚动      // click: true,//点击事件      // dblclick: {  //双击      //     delay: 300      // },      // tap: true      // bounce: {   // //临界点的动画      //     top: false,      //     bottom: true,      //     left: true,      //     right: true      // }      // probeType: 2,//0|1|2|3  0时不会派发滚动事件 1时滚动停止之后触发一次 2滚动过程中触发 3实时触发      // preventDefault: ture //阻止默认事件   }#方法控制滚动条滚动到当前元素实例对象.scrollToElement(dom节点,time,offsetx,offsety)time 滚动条运动到dom节点的时间offsetx 滚动条距dom节点x轴的距离 true 默认在父元素的中间offsety 滚动条距dom节点y轴的距离 true 默认在父元素的中间控制滚动位置实例对象.scrollTo(x,y,time)x：x轴的距离y: y轴的距离time:时间刷新滚动条 当子元素的dom结构发生变化时重新计算滚动距离实例对象.refresh();#事件   实例对象.on('scroll',function(){ 滚动事件 默认不会触发   this指向实例对象   })   实例对象.on('scrollEnd',function(){ 滚动条停止滚动 回到初始状态   this指向实例对象   })   实例对象.on('touchEnd',function(){}) 手指松开#属性实例对象.x 当前x轴的距离实例对象.y 当前y轴的距离实例对象.maxScrollX x轴最大滚动距离实例对象.maxScrollY y轴最大滚动距离只找父元素下第一个子元素,子元素的宽度和高度必须超过父元素才能撑开滚动条父元素添加 position: relative; overflow:hidden横向滚动条子元素的宽度不会被撑开所以要动态计算子元素的宽度#Zpeto简介：Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。需要注意的是Zepto的一些可选功能是专门针对移动端浏览器的；因为它的最初目标在移动端提供一个精简的类似jquery的js库。下载：http://www.css88.com/doc/zeptojs_api/#download与jquery的区别：zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。jquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。Demo： <!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <script src="./zepto.js"></script></head><body>    <div class="delete">删除</div>    <script>        $('.delete').on("click", function() {            console.log($(this))        })    </script></body></html>#FastClick移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件，这是为了检查用户是否在做双击。为了能够立即响应用户的点击事件，才有了FastClick。Demo：<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .topSlide {            position: relative;            background-color: blue;            margin: auto;            margin-top: 30px;        }                .topSlide p {            text-align: center;            font-size: 20px;            line-height: 36px;            color: white;        }                .result {            position: relative;            background-color: green;            margin: auto;            margin-top: 30px;            color: white;        }    </style></head><body>    <div id="t1" class="topSlide">        <p>click me</p>    </div>    <div id="t2" class="topSlide">        <p>click me(by FastClick)</p>    </div>    <div id="result1" class="result">        <h3>touchStart</h3>        <p id="result1p">haha</p>    </div>    <div id="result2" class="result">        <h3>click(ms)</h3>        <p id="result2p">haha</p>    </div>    <div id="result3" class="result">        <h3>touchEnd(ms)</h3>        <p id="result3p">haha</p>    </div>    <script src="./fastclick.js"></script>    <script>        if ('addEventListener' in document) {            document.addEventListener('DOMContentLoaded', function() {                // FastClick.attach(document.body);                var startTime;                var log = function(msg) {                    var t = (new Date().getTime() - startTime);                    if (msg == 'touchStart')                        document.querySelector("#result1p").innerHTML = t;                    else if (msg == 'touchEnd')                        document.querySelector("#result3p").innerHTML = t;                    else if (msg == 'mouseClick')                        document.querySelector("#result2p").innerHTML = t;                    console.log(msg);                };                var touchStart = function() {                    startTime = new Date().getTime();                    log('touchStart');                };                var mouseClick = function() {                    log('mouseClick');                };                var touchEnd = function() {                    log('touchEnd');                };                var me = document.querySelector("#t2")                FastClick.attach(me);                document.querySelector("#t1").addEventListener("click", mouseClick)                document.querySelector("#t2").addEventListener('click', mouseClick);                document.addEventListener('touchstart', touchStart);                document.addEventListener('touchend', touchEnd);            }, false);        }    </script></body></html>不需要使用fastclick的情况以下这几种情况是不需要使用fastclick：1、FastClick是不会对PC浏览器添加监听事件2、Android版Chrome 32+浏览器，如果设置viewport meta的值为width=device-width，这种情况下浏览器会马上出发点击事件，不会延迟300毫秒。   <meta name="viewport" content="width=device-width, initial-scale=1"\>3、所有版本的Android Chrome浏览器，如果设置viewport meta的值有user-scalable=no，浏览器也是会马上出发点击事件。4、IE11+浏览器设置了css的属性touch-action: manipulation，它会在某些标签（a，button等）禁止双击事件，IE10的为-ms-touch-action: manipulation使用needsclick过滤特定的元素如果页面上有一些特定的元素不需要使用fastclick来立刻触发点击事件，可以在元素的class上添加needsclick:   <a class="needsclick">Ignored by FastClick</a>#SvgSVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用来定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失SVG 是万维网联盟的标准SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体使用：SVG 文件可通过以下标签嵌入 HTML 文档：<embed>、<object> 或者 <iframe>。SVG的代码可以直接嵌入到HTML页面中，或您可以直接链接到SVG文件。<embed src="a.svg" type="image/svg+xml" />    <object data="a.svg" type="image/svg+xml"></object>    <iframe src="a.svg"></iframe>    <svg xmlns="http://www.w3.org/2000/svg" version="1.1">        <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red" />     </svg>Api地址：http://www.runoob.com/svg/svg-inhtml.html#Webwork#简介JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。Web Worker 有以下几个使用注意点。（1）同源限制分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。（2）DOM 限制Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。（3）通信联系Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。（4）脚本限制Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。（5）文件限制Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。# 使用：主线程：      var worker = new Worker('work.js');        worker.postMessage('Hello World');        worker.onmessage = function(event) {            console.log('主线程：' + event.data);            // 执行任务            if (event.data != "子线程结束") {                worker.postMessage('stop');            } else {                worker.terminate();            }        }子线程：//this.addEventListener("message", () => {})// addEventListener("message", () => {})	self.addEventListener('message', function(e) {    console.log(e.data)    var data = e.data;    switch (data) {        case 'start':            self.postMessage("子线程开始");            break;        case 'stop':            self.postMessage('子线程结束');            self.close(); // Terminates the worker.            break;        default:            self.postMessage('Unknown command: ' + data.msg);    };}, false);#扩展apiWorker 加载脚本Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。   importScripts('script1.js');   importScripts('script1.js', 'script2.js');错误处理主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。   worker.onerror(function (event) {});   // 或者   worker.addEventListener('error', function (event) {});关闭 Worker使用完毕，为了节省系统资源，必须关闭 Worker。   // 主线程   worker.terminate();   // Worker 线程   self.close();#同页面的Web Worker通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。<!DOCTYPE html>  <body>    <script id="worker" type="app/worker">      addEventListener('message', function () {        postMessage('some message');      }, false);    </script>  </body></html>上面是一段嵌入网页的脚本，注意必须指定<script>标签的type属性是一个浏览器不认识的值，上例是app/worker。然后，读取这一段嵌入页面的脚本，用 Worker 来处理。   var blob = new Blob([document.querySelector('#worker').textContent]);   var url = window.URL.createObjectURL(blob);   var worker = new Worker(url);   worker.onmessage = function (e) {   // e.data === 'some message'   };上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。#Canvas<canvas>是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。Demo：<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title></head><body>    <canvas id="canvas"></canvas>    <script>        var canvas = document.getElementById('canvas');        var ctx = canvas.getContext('2d');        ctx.fillStyle = 'green';        ctx.fillRect(10, 10, 100, 100);    </script></body></html>#基本api使用：#颜色、样式和阴影：fillStyle：设置或返回用于填充绘画的颜色、渐变或模式属性值color	指示绘图填充色的 CSS 颜色值。默认值是 #000000。gradient	用于填充绘图的渐变对象（线性或放射性）pattern	用于填充绘图的 pattern 对象如：   var c = document.getElementById("myCanvas");   var ctx = c.getContext("2d");   var my_gradient = ctx.createLinearGradient(0, 0, 0, 170);   my_gradient.addColorStop(0, "black");   my_gradient.addColorStop(1, "white");   ctx.fillStyle = my_gradient;   ctx.fillRect(20, 20, 150, 100);strokeStyle 属性设置或返回用于笔触的颜色、渐变或模式。属性如fillStyleDemo:   var c = document.getElementById("myCanvas");   var ctx = c.getContext("2d");   ctx.font = "30px Verdana";   // 创建渐变   var gradient = ctx.createLinearGradient(0, 0, c.width, 0);   gradient.addColorStop("0", "magenta");   gradient.addColorStop("0.5", "blue");   gradient.addColorStop("1.0", "red");   // 用渐变进行填充   ctx.strokeStyle = gradient;   ctx.strokeText("Big smile!", 10, 50);shadowColor 属性设置或返回用于阴影的颜色。ctx.shadowColor="black";shadowBlur 属性设置或返回阴影的模糊级数。ctx.shadowBlur=20;shadowOffsetX 属性设置或返回形状与阴影的水平距离。   shadowOffsetX=0 //指示阴影位于形状的正下方。   shadowOffsetX=20 //指示阴影位于形状 left 位置右侧的 20 像素处。   shadowOffsetX=-20 //指示阴影位于形状 left 位置左侧的 20 像素处。shadowOffsetY 属性设置或返回形状与阴影的垂直距离。   shadowOffsetY=0 //指示阴影位于形状的正下方。   shadowOffsetY=20 //指示阴影位于形状 top 位置下方的 20 像素处。   shadowOffsetY=-20 //指示阴影位于形状 top 位置上方的 20 像素处。createLinearGradient() 方法创建线性的渐变对象。   context.createLinearGradient(x0,y0,x1,y1);参数	描述x0	渐变开始点的 x 坐标y0	渐变开始点的 y 坐标x1	渐变结束点的 x 坐标y1	渐变结束点的 y 坐标createPattern() 方法在指定的方向内重复指定的元素。   context.createPattern(image,"repeat\|repeat-x\|repeat-y\|no-repeat");createRadialGradient () 方法创建放射状/圆形渐变对象   context.createRadialGradient(x0,y0,r0,x1,y1,r1);addColorStop() 方法规定 gradient 对象中的颜色和位置。   var grd=ctx.createLinearGradient(0,0,170,0);   grd.addColorStop(0,"black");#线条样式lineCap 属性设置或返回线条末端线帽的样式。值	描述butt	默认。向线条的每个末端添加平直的边缘。round	向线条的每个末端添加圆形线帽。square	向线条的每个末端添加正方形线帽。lineJoin 属性设置或返回所创建边角的类型，当两条线交汇时。Bevel: 创建斜角Round: 创建圆角。Miter: 默认。创建尖角。lineWidth 属性设置或返回当前线条的宽度，以像素计。miterLimit 属性设置或返回最大斜接长度。只有当 lineJoin 属性为 "miter" 时，miterLimit 才有效。边角的角度越小，斜接长度就会越大。Demo：   ctx.lineWidth = 10;   ctx.lineJoin = "miter";   ctx.miterLimit = 5;   ctx.moveTo(20, 20);   ctx.lineTo(50, 27);   ctx.lineTo(20, 34);   ctx.stroke();#矩形rect() 方法创建矩形。   context.rect(x,y,width,height);fillRect() 方法绘制“已填色”的矩形。默认的填充颜色是黑色，fillStyle** 属性来设置用于填充绘图的颜色、渐变或模式。**   context.fillRect(x,y,width,height);strokeRect() 方法绘制矩形（不填色）。笔触的默认颜色是黑色。   context.strokeRect(x,y,width,height);clearRect() 方法清空给定矩形内的指定像素。   context.clearRect(x,y,width,height);#路径fill() 方法填充当前的图像（路径）。默认颜色是黑色。使用 fillStyle 属性来填充另一种颜色/渐变ctx.rect(20, 20, 150, 100);ctx.fillStyle = "green";ctx.fill();stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。beginPath() 方法开始一条路径，或重置当前的路径。   var ctx=c.getContext("2d");   ctx.beginPath();   ctx.lineWidth="5";   ctx.strokeStyle="red"; // 红色路径   ctx.moveTo(0,75);   ctx.lineTo(250,75);   ctx.stroke(); // 进行绘制   ctx.beginPath();   ctx.strokeStyle="blue"; // 蓝色路径   ctx.moveTo(50,0);   ctx.lineTo(150,130);   ctx.stroke(); // 进行绘制moveTo开始一条直线的方法closePath() 方法创建从当前点到开始点的路径，无参数lineTo()方法添加一个新点，然后创建从该点到画布中最后指定点的线条（该方法并不会创建线条）。setLineDash：设置虚线setLineDash（a,b）:a为实线的长度，b为虚线的长度clip() 方法从原始画布中剪切任意形状和尺寸。Demo：// 剪切矩形区域ctx.rect(50, 20, 200, 120);ctx.stroke();ctx.clip();quadraticCurveTo()方法通过使用表示二次贝塞尔曲线的指定控制点，向当前路径添加一个点。ctx.beginPath();ctx.moveTo(20, 20);ctx.quadraticCurveTo(20, 100, 200, 20);ctx.stroke();bezierCurveTo() 方法通过使用表示三次贝塞尔曲线的指定控制点，向当前路径添加一个点。ctx.beginPath();ctx.moveTo(20, 20);ctx.bezierCurveTo(20, 100, 200, 100, 200, 20);arc() 方法创建弧/曲线（用于创建圆或部分圆）。ctx.beginPath();ctx.arc(100, 75, 50, 0, 2 * Math.PI);ctx.stroke();context.arc(x,y,r,sAngle,eAngle,counterclockwise);参数	描述x	圆的中心的 x 坐标。y	圆的中心的 y 坐标。r	圆的半径。sAngle	起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。eAngle	结束角，以弧度计。counterclockwise	可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。arcTo() 方法在画布上创建介于两个切线之间的弧/曲线。Demo：ctx.beginPath();ctx.beginPath();ctx.moveTo(20, 20); // 创建开始点ctx.lineTo(100, 20); // 创建水平线ctx.arcTo(150, 20, 150, 70, 50); // 创建弧ctx.lineTo(150, 120); // 创建垂直线ctx.stroke();context.fillRect(x1,y1,x2,y2,r);参数	描述x1	弧的起点的 x 坐标y1	弧的起点的 y 坐标x2	弧的终点的 x 坐标y2	弧的终点的 y 坐标r	弧的半径isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。Demo:ctx.rect(20, 20, 150, 100);if (ctx.isPointInPath(20, 50)) {ctx.stroke();};#转换scale() 方法缩放当前绘图，更大或更小。Demo:ctx.strokeRect(5, 5, 25, 15);ctx.scale(2, 2);ctx.strokeRect(5, 5, 25, 15);rotate() 方法旋转当前的绘图。旋转角度Demo:ctx.rotate(20 * Math.PI / 180);ctx.fillRect(50, 20, 100, 50);translate() 方法重新映射画布上的 (0,0) 位置。ctx.translate(70, 70);ctx.fillRect(10, 10, 100, 50);#文本font 属性设置或返回画布上文本内容的当前字体属性。Demo：ctx.font = "40px Arial";ctx.fillText("Hello World", 10, 50);textAlign 属性根据锚点，设置或返回文本内容的当前对齐方式。Demo：ctx.textAlign = "end";ctx.fillText("textAlign=end", 150, 80);textBaseline 属性设置或返回在绘制文本时的当前文本基线。ctx.textBaseline = "top";ctx.fillText("Top", 5, 100);fillText() 方法在画布上绘制填色的文本。文本的默认颜色是黑色。ctx.font = "20px Georgia";ctx.fillText("Hello World!", 10, 50);strokeText() 方法在画布上绘制文本（没有填色）。文本的默认颜色是黑色。Demo：ctx.font = "20px Georgia";ctx.strokeText("Hello World!", 10, 50);#图像绘制drawImage() 方法在画布上绘制图像、画布或视频。方法也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。   context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);参数	描述img	规定要使用的图像、画布或视频。sx	可选。开始剪切的 x 坐标位置。sy	可选。开始剪切的 y 坐标位置。swidth	可选。被剪切图像的宽度。sheight	可选。被剪切图像的高度。x	在画布上放置图像的 x 坐标位置。y	在画布上放置图像的 y 坐标位置。width	可选。要使用的图像的宽度。（伸展或缩小图像）height	可选。要使用的图像的高度。（伸展或缩小图像）Demo1：   let $img = new Image()   $img.src = "/img/databse.jpg";   $img.onload = function() {      ctx.drawImage($img, 0, 0, 300, 300, 0, 0, 300, 300)   }Demo2：（播放视频）   let v = document.querySelector("\#vedios")   let lasttime   requestAnimationFrame(() => {      if (lasttime && new Date().getTime() - lasttime \> 30) {      ctx.drawImage(v, 0, 0, 270, 135);      }   })#像素操作createImageData() 方法创建新的空白 ImageData 对象。新对象的默认像素值 transparent black。对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：R - 红色 (0-255)G - 绿色 (0-255)B - 蓝色 (0-255)A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)因此 ，transparent black 表示 (0,0,0,0)。color/alpha 以数组形式存在，并且既然数组包含了每个像素的四条信息，数组的大小是 ImageData 对象的四倍。（获得数组大小有更简单的办法，就是使用 ImageDataObject.data.length）demo：   var imgData = ctx.createImageData(100, 100);   for (var i = 0; i < imgData.data.length; i += 4) {      imgData.data[i + 0] = 255;      imgData.data[i + 1] = 0;      imgData.data[i + 2] = 0;      imgData.data[i + 3] = 255;   }   ctx.putImageData(imgData, 10, 10);getImageData() 方法返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据。对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：R - 红色 (0-255)G - 绿色 (0-255)B - 蓝色 (0-255)A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)color/alpha 以数组形式存在，并存储于 ImageData 对象的 data 属性中。Demo：   var imgData = ctx.getImageData(10, 10, 50, 50);   ctx.putImageData(imgData, 10, 70);putImageData() 方法将图像数据（从指定的 ImageData 对象）放回画布上。putImageData() 方法将图像数据（从指定的 ImageData 对象）放回画布上。参数	描述imgData	规定要放回画布的 ImageData 对象。x	ImageData 对象左上角的 x 坐标，以像素计。y	ImageData 对象左上角的 y 坐标，以像素计。dirtyX	可选。水平值（x），以像素计，在画布上放置图像的位置。dirtyY	可选。水平值（y），以像素计，在画布上放置图像的位置。dirtyWidth	可选。在画布上绘制图像所使用的宽度。dirtyHeight	可选。在画布上绘制图像所使用的高度。globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。Demo：ctx.fillStyle = "red";ctx.fillRect(20, 20, 75, 50);ctx.globalCompositeOperation = "source-over";ctx.fillStyle = "blue";ctx.fillRect(50, 50, 75, 50);值	描述source-over	默认。在目标图像上显示源图像。source-atop	在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。source-in	在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。source-out	在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。destination-over	在源图像上方显示目标图像。destination-atop	在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。destination-in	在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。destination-out	在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。lighter	显示源图像 + 目标图像。copy	显示源图像。忽略目标图像。xor	使用异或操作对源图像与目标图像进行组合。#canvas常用方法save()：保存当前环境的状态restore()：返回之前保存过的路径状态和属性一般是save和restore方法相结合着使用；Demo：   context.save(); //保存第一次的状态context.rotate(30 / 180 * Math.PI);context.beginPath();context.moveTo(0, -180);context.lineTo(0, -200);context.stroke();context.restore(); //进行第二次绘制前，将状态恢复到初始状态context.rotate(30 / 180 * Math.PI);context.beginPath();context.moveTo(0, -140);context.lineTo(0, -160);context.stroke();  toDataURL()可以得到以 base64 编码的 dataURL demo：function getBase64(url) {   //通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比   // createElement() 创建 \<img\> 省去了 append()，也就避免了文档冗余和污染      var Img = new Image(),      dataURL = '';      Img.src = url;      Img.onload = function() { //要先确保图片完整获取到，这是个异步事件         var canvas = document.createElement("canvas"), //创建canvas元素         width = Img.width, //确保canvas的尺寸和图片一样         height = Img.height;         canvas.width = width;         canvas.height = height;         canvas.getContext("2d").drawImage(Img, 0, 0, width, height);         //将图片绘制到canvas中         dataURL = canvas.toDataURL('image/jpeg'); //转换图片为dataURL      };#弧度制和角度制：1° = π / 180 ≈ 0.01745 rad1rad = 180 / π = 57.30°角度制，就是用角的大小来度量角的大小的方法。在角度制中，把周角的1/360看作1度，那么，半周就是180度，一周就是360度。由于1度的大小不因为圆的大小而改变，所以角度大小是一个与圆的半径无关的量。弧度制，顾名思义，就是用弧的长度来度量角的大小的方法。单位弧度定义为圆周上长度等于半径的圆弧与圆心构成的角。由于圆弧长短与圆半径之比，不因为圆的大小而改变，所以弧度数也是一个与圆的半径无关的量。角度以弧度给出时，通常不写弧度单位，有时记为rad或R三角函数：# weinre手机调试# 简介weinre是一款非常好用的远程调试工具。功能与网页浏览器的开发者工具基本类似，但这个工具更适合用于移动端web的调试。# 安装weinre基于nodejs，因此首先要安装nodejs，然后使用npm进行安装：npm -g install weinre# 运行weinre --httpPort 8081 --boundHost -all-主要参数解析httpPort:调试服务器运行的端口，默认8080 boundHost:调试服务器绑定的IP地址或域名，默认localhost# 修改目标文件使用webkit的浏览器（NOTE:由于weinre的设计更多的是基于webkit的浏览器，因此建议使用chrome/safari）访问weinre服务器：http://localhost:8081打开debug面板：http://localhost:8081/client/#anonymous获取本机的IP地址，例如：192.168.1.101，添加如下js文件到需要调试的目标文件的头部：<script src="http://192.168.1.101:8081/target/target-script-min.js#anonymous"></script># 访问在移动设备上访问本机IP地址并且在debug面板中可以监听到移动设备对目标页面的访问：#手机设备事件：需要用到HTML5的DeviceOrientation特性。它提供的DeviceMotion事件封装了设备的运动传感器时间，通过改时间可以获取设备的运动状态、加速度等数据（另还有deviceOrientation事件提供了设备角度、朝向等信息）。#DeviceMotionDeviceMotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。acceleration 只读提供了设备在X,Y,Z轴方向上加速度的对象。加速度的单位为 m/s2。accelerationIncludingGravity 只读提供了设备在X,Y,Z轴方向上带重力的加速度的对象。加速度的单位为 m/s2rotationRate 只读提供了设备在 alpha，beta， gamma轴方向上旋转的速率的对象。旋转速率的单位为 ?°/s 。interval 只读表示从设备获取数据的频率，单位是毫秒。Demo:<!DOCTYPE html><html><head lang="en">    <meta charset="UTF-8">    <title></title>    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />    <style type="text/css">        * {            margin: 0;            padding: 0;        }                div {            width: 80%;            border: solid 1px #ccc;            padding: 5px;            height: 300px;            margin: 30px auto;            line-height: 300px;            text-align: center        }    </style></head><body>    <div>摇一摇抽奖</div>    <script type="text/javascript">        //定义保存开始和结束的值        var startx = starty = endx = endy = 0;        //将多个奖项保存到数组中        var dataA = ["一等奖", "二等奖", "三等奖", "四等奖", "谢谢参与"];        //绑定手机摇动时的事件        window.addEventListener("devicemotion", function(event) {            //接收传来的数据对象            var data = event.accelerationIncludingGravity;            //根据对象获取开始坐标值            startx = data.x;            starty = data.y;            //如果有距离            if (startx - endx > 25 || starty - endy > 25) {                //生成一个随机数                var i = Math.floor(Math.random() * 5);                //根据随机数设置奖项显示的内容                document.querySelector("div").innerHTML = dataA[i]            }            endx = startx;            endy = starty;        })    </script></body></html>#DeviceOrientationEvent要接收设备方向变化信息，你只需要注册监听deviceorientation事件：根据event对象的三个方向的参数来确定设备的旋转角度。其中，alpha的取值范围是0-360,这个需要根据设备的指南针设定情况而定，一般来说，设备指向正北方向时为0.beta值为设备绕x轴旋转的角度，取值范围为-180-180。gamma取值范围-90-90.属性值1.alpha      设备指示的方向，根据指南针的设定情况而定2.beta     设备绕x轴旋转的角度3.gamma     设备绕y轴旋转的角度这里面alpha值的意义并不大，主要参考beta和gamma值。当屏幕从水平沿y轴向左倾斜时gamma值变为负值，向右倾斜变为正值。档屏幕从水平沿x轴向前倾斜时beta值变为正值，向后倾斜时变为负值。所以，如果我们设定一个阈值，当beta和gamma的绝对值大于这个阈值时，我们就认为设备发生了旋转。另外根据beta和gamma的值来判断向左倾斜还是向右倾斜，以及倾斜的程度。两者的区别：1.DeviceOrientationEvent的值是相对于初始状态的差值，只要设备方向不变，怎么动都不会影响数值；2.DeviceMotionEvent是相对于之前的某个瞬间值的差值时间比，即变化的速度，一旦设备静止则会恢复为0。#orientationChange此时的event对象不包含任何有价值的信息，因为唯一相关信息可以通过window.orientation访问到orientation属性它有三个值：0,90，-900为竖屏模式（portrait），-90意味着该设备横向旋转到右侧的横屏模式（landscape），而90表示该设备是横向旋转到左边的横屏模式（landscape）。还有一个是180，表示竖屏但是是翻转过来的竖屏模式。但这种模式至今尚未得到支持。<!DOCTYPE html><html><head lang="en">    <meta charset="UTF-8">    <title></title>    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />    <style type="text/css">        * {            margin: 0;            padding: 0;        }                div {            width: 80%;            border: solid 1px #ccc;            padding: 5px;            height: 300px;            margin: 30px auto;            line-height: 300px;            text-align: center        }    </style>    <script type="text/javascript" src="js/jquery-1.11.3.min.js">    </script></head><body>    <div>横屏显示</div>    <script type="text/javascript">        $(function() {            window.addEventListener("orientationchange", function(event) {                //竖屏方向                if (window.orientation == 0 || window.orientation == 180 || window.orientation == -180) {                    document.querySelector("div").innerHTML = "竖屏显示"                } else { //横屏方向                    document.querySelector("div").innerHTML = "横屏显示"                }            }, false)        })    </script></body></html>#摄像头的调用HTML 5 的getUserMedia API提供了访问媒体的能力, 基于该特性, 开发者可以不依赖任何浏览器插件下去访问视频和音频等设备.如navigator.mediaDevices.getUserMedia#不同浏览器的api：//访问用户媒体设备的兼容方法        function getUserMedia(constraints, success, error) {            if (navigator.mediaDevices.getUserMedia) {                //最新的标准API                navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error);            } else if (navigator.webkitGetUserMedia) {                //webkit核心浏览器                navigator.webkitGetUserMedia(constraints, success, error)            } else if (navigator.mozGetUserMedia) {                //firfox浏览器                navigator.mozGetUserMedia(constraints, success, error);            } else if (navigator.getUserMedia) {                //旧版API                navigator.getUserMedia(constraints, success, error);            }        }#使用：navigator.mediaDevices.getUserMedia(constraints) 返回一个 Promise 对象，成功后会resolve回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise会reject回调一个  PermissionDeniedError 或者 NotFoundError 。navigator.mediaDevices.getUserMedia(constraints)   .then(function(stream) {         /* 使用这个stream stream */   })   .catch(function(err) {         /* 处理error */   });#参数：Constraints：constraints 参数是一个包含了video 和 audio两个成员的MediaStreamConstraints 对象，用于说明请求的媒体类型。必须至少一个类型或者两个同时可以被指定。如果浏览器无法找到指定的媒体类型或者无法满足相对应的参数要求，那么返回的Promise对象就会处于rejected［失败］状态，NotFoundError作为rejected［失败］回调的参数。基本用法：   { audio: true, video: true }使用1280x720的摄像头分辨率：{audio: true,video: { width: 1280, height: 720 }}获取最低为1280x720的分辨率：{   audio: true,   video: {      width: { min: 1280 },      height: { min: 720 }   }}当请求包含一个ideal（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定的理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。   {      audio: true,      video: {         width: { min: 1024, ideal: 1280, max: 1920 },         height: { min: 776, ideal: 720, max: 1080 }      }   }或：{   audio: true,   video: {      width: { ideal: 1280 },      height: { ideal: 720 }   }}优先使用前置摄像头（如果有的话）：   { audio: true, video: { facingMode: "user" } }强制使用后置摄像头：   { audio: true, video: { facingMode: { exact: "environment" } } }#SrcObject和createObjectURL#SrcObjectHTMLMediaElement 接口的 srcObject 属性设定或返回一个对象，这个对象提供了一个与HTMLMediaElement关联的媒体源，这个对象通常是 MediaStream ，但根据规范可以是 MediaSource， Blob 或者 File。video.srcObject = stream;#createObjectURLURL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。objectURL = URL.createObjectURL(blob);在每次调用 createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。#设备信息获取window.navigator对象包含有关访问者浏览器的信息。#属性属性	描述navigator.appCodeName;	//返回与浏览器相关的内部代码名 都为Mozillanavigator.appName;	//返回浏览器正式名称 均为Netscapenavigator.appVersion;	//返回浏览器版本号navigator.cookieEnabled;	//返回浏览器是否启用cookie，true和falsenavigator.geolocation;	//返回地理定位信息(h5)navigator.javaEnabled();	//检测当前浏览器是否支持 Java，从而知道浏览器是否能显示Java 小程序(IE,chrome返回true，firefox返回false)navigator.language;	//返回浏览器的首选语言navigator.mimeTypes;	//返回浏览器支持的Mime类型navigator.msManipulationViewsEnabled;	//仅支持IE，truenavigator.msMaxTouchPoints;	//字面意思是最大的触摸点，IE为0，其他不支持navigator.msPointerEnabled;	//IE为true，其他不支持navigator.onLine;	//是否连接互联网，均返回true(未断网)navigator.platform;	//所在平台，返回win32，//android,iosnavigator.plugins;	//返回浏览器插件集合navigator.preference;	//允许一个已标识的脚本获取并设置特定的 Navigator 参数navigator.product;	//浏览器产品名，返回geckonavigator.systemLanguage;	//获取系统语言，IE支持，返回zh-cnnavigator.userAgent;	//判断浏览器类型navigator.userLanguage;	//返回操作系统的自然语言设置,IE支持，返回zh-cn#方法属性	描述navigator.msLaunchUri;	//回调函数，未研究navigator.taintEnabled;	//回调函数navigator.hasOwnProperty;	//意思是是否支持属性，用法如下document.hasOwnProperty("ontouchstart");	//电脑返回false，手机为true